#+OPTIONS: num:nil toc:nil

#+ATTR_HTML: :target "_blank"
#+ATTR_HTML: :target "_blank"

* Getting Started with React and Rails

As a Ruby web developer, you are probably already aware that [[http://facebook.github.io/react/][react.js]] is hot on
the front end. Official *react.js* support in Rails is provided by
Facebook via the [[https://github.com/reactjs/react-rails][react-rails]] gem.

#+ATTR_HTML: :target "_blank"
[[https://github.com/zetachang/react.rb#changing-the-top-level-component-name-and-search-path][React.rb/reactive-ruby]] (henceforth *react.rb*) gives you more Ruby joy
by allowing you to write react components in Ruby, courtesy of [[http://opalrb.org][Opal]]

I will write in depth about react.rb in subsequent posts, but now
let's get *react.rb* up and running on Rails.

** Generate a rails project with opal

#+ATTR_HTML: :target "_blank"

Create a rails project using [[http://opalrb.org][Opal]]:

#+BEGIN_SRC bash
% rails new getting-started-react-rails --javascript=opal
#+END_SRC

** Add react.rb gems to Gemfile

#+BEGIN_SRC ruby
gem 'reactive-ruby', '0.7.28' # nail down compatible version w/ react-rails
gem 'react-rails', '1.3.2' # not compatible ith 1.4.* yet
gem 'opal-rails' # already added w/the --javascript=opal option
gem 'therubyracer', platforms: :ruby # Required for prerendering
#+END_SRC

Then run =bundle install=

** Configure application.rb

Starting with *Opal 0.8.**, we no longer need to configure =application.js=;
we can instead use =require= statements in =application.rb=.

1.  Remove =application.rb=
#+BEGIN_SRC bash
% rm app/assets/javascripts/application.js
#+END_SRC
1.  [@2] Copy the following text into =app/assets/javascripts/application.rb=:
#+BEGIN_SRC ruby
require 'opal'
require 'opal_ujs'
require 'turbolinks'
require 'react'
require 'react_ujs'
require 'components' # to include isomorphic react components on the client
require_tree '.'
#+END_SRC

** Setup for isomorphic React components

#+ATTR_HTML: :target "_blank"
#+ATTR_HTML: :target "_blank"
A big perk of *react.js* is /isomorphic code/ (same code on server and
client) which leads to a unified UI layer. [[https://github.com/reactjs/react-rails][react-rails]] gives you
convenient *react.js* integration with Rails, including server-rendered
components and other goodies as detailed in this [[http://bensmithett.com/server-rendered-react-components-in-rails/][article]].  *react.rb*
extends these advantages to give you isomorphic code in Ruby!  I like this
quote from the afore-linked article.

#+BEGIN_QUOTE
/The Holy Grail. The united UI layer. Serve up real HTML on first page load,
then kick off a client side JS app. All without duplicating a single line of UI code./
#+END_QUOTE

To support isomorphic *react.rb* components you will need to setup a
structure to /share/ these components:


1. Make an =app/views/components= directory to hold the components.
#+BEGIN_SRC bash
%  mkdir app/views/components
#+END_SRC
1. [@2] Create a text file, =app/views/components.rb=, with the following contents:
#+BEGIN_SRC ruby
require 'opal'
require 'reactive-ruby'
require_tree './components'
#+END_SRC

You will have noticed that while converting to =application.rb=, I
=require='d this =components.rb= file to allow these isomorphic
components to be be included on the client side.

** Creating client side only react components

It should go without saying that you can create /client-only/ *react.rb*
components without any setup.  The opal files you write will be found
by Rails anywhere that the asset pipeline loads javascript files, but
I would recommend a structure similar to how *react-rails* sets up the
structure for react.js components -- in the directory
=app/assets/javascripts/components=

We will address client only components later in the article

** Make a controller to demonstrate react components

We will be covering several types of components, let's make a
controller to display them:

#+BEGIN_SRC bash
% rails g controller home isomorphic iso_convention search_path client_only
#+END_SRC

** Create your first React Component

So now that we're setup for isomorphic components, lets make our first
*react.rb* component.  We'll start with a simple "Hello World" component.
This component renders a single, required param (/prop/ in
*react.js* lingo) message of type =String= in an =h1=
element, along with a button that runs =alert()= with the
same message

Put the following text in this file: =app/views/components/hello.rb=

#+BEGIN_SRC ruby
class Hello
  include React::Component
  required_param :message, type: String
  def message
    "Hello #{what}"
  end
  def render
    div {
      h1 { message }
      button {"Press me"}.on(:click) {alert message}
    }
  end
end
#+END_SRC

Use =render_component" to render the =Hello= component in your controller:

#+BEGIN_SRC ruby
class HomeController < ApplicationController
  def isomorphic
    render_component 'Hello', message: 'World'
  end
end
#+END_SRC

You can see that =render_component= takes two arguments:

1.  A string identifying the react component, 'Hello'.
1.  An optional key/value pair containing parameters.  Here, we pass the
    require parameter =:message= along with its value.

Start the server, then visit http://localhost:3000/home/isomorphic to view the component.
By default it prerenders on the server, but you can force Rails to not
prerender by appending =?no_prerender=1= to the url, like so

#+BEGIN_SRC bash
http://localhost:3000/home/index?no_prerender=1
#+END_SRC

Let's take a quick look on what gets returned by the server (formatted to look better)

For http://localhost:3000/home/isomorphic we see the `<h1>` and button rendered from the server
#+BEGIN_SRC html
  <div data-react-class="React.TopLevelRailsComponent"
       data-react-props="{&quot;render_params&quot;:{&quot;message&quot;:&quot;World&quot;},&quot;component_name&quot;:&quot;Hello&quot;,&quot;controller&quot;:&quot;Home&quot;}">
    <div data-reactid=".3hx9dqn6rk"
         data-react-checksum="487927662">
      <h1 data-reactid=".3hx9dqn6rk.0">Hello World</h1>
      <button data-reactid=".3hx9dqn6rk.1">Press me</button>
    </div>
  </div>
#+END_SRC

For http://localhost:3000/home/isomorphic?no_prerender=1 there is no prerendering and the rendering is done by the client
#+BEGIN_SRC html
  <div data-react-class="React.TopLevelRailsComponent"
       data-react-props="{&quot;render_params&quot;:{&quot;message&quot;:&quot;World&quot;},&quot;component_name&quot;:&quot;Hello&quot;,&quot;controller&quot;:&quot;Home&quot;}">
  </div>
#+END_SRC

** Rails conventions and isomorphic components

In the Rails tradition of "convention over configuration", you can
organize your components to assign a
"default" component for that controller.  For example, you can
assign component =#iso_convention= to =HomeController= as follows:

1.  Create the component directory for the =HomeController=:
#+BEGIN_SRC bash
% mkdir app/views/components/home
#+END_SRC
1.  [@2] Place the following code into
    =app/views/components/home/iso_convention.rb=
#+BEGIN_SRC ruby
  module Components
    class IsoConvention
      include React::Component

      def render
        h1 { "the message is: #{params[:message]}" }
      end
    end
  end
#+END_SRC

We now call =render_component()= with only the params in the
controller's action.  The *default* component gets called.

#+BEGIN_SRC ruby
class HomeController < ApplicationController
  def iso_convention
    render_component message: 'World'
  end
end
#+END_SRC

** The search path

  Where possible, you should stick with the conventions, but there are
  times where you will not, for example, with shared components.  The
  search path for isomorphic components is described [[https://github.com/zetachang/react.rb#changing-the-top-level-component-name-and-search-path][here]] which says

#+BEGIN_QUOTE
Changing the top level component name and search path

You can control the top level component name and search path.

You can specify the component name explicitly in the
render_component method. render_component "Blatz" will search the
path for a component class named =Blatz= regardless of the controller
method.

Searching for components normally works like this: Given a
controller named "Foo", then the component should be either in the
=Components::Foo= module, the =Components= module (no controller -
useful if you have just a couple of shared components) or just the
outer scope (i.e. =Module=) which is useful for small apps.

Saying "render_component '::Blatz'" will only search the outer scope,
while ~::Foo::Blatz~ will look only in the module ~Foo~ for a class
named ~Blatz~.
#+END_QUOTE

** Playing around with the search path
Let's play around with several components with the same name and see
how the search path resolves which component to use.  Create the 2 files below

=app/views/components/search_path.rb=
#+BEGIN_SRC ruby

  # This class departs from 1 class/file and diretory
  # strctureconvention, using this to test search path

class SearchPath1
  include React::Component
  def render
    h1 {"::SearchPath"}
  end
end

module Home
  class SearchPath1
    include React::Component
    def render
      h1 {"Home::SearchPath"}
    end
  end
end

module Components
  class SearchPath
    include React::Component
    def render
      h2 { 'Components::SearchPath' }
    end
  end
end

module Components
  module Home
    class SearchPath1
      include React::Component
      def render
        h2 { 'Components::Home::SearchPath' }
      end
    end
  end
end
#+END_SRC

For ~HomeController~ to render the "default" component, call =render_component()=.

#+BEGIN_SRC ruby
class HomeController < ApplicationController
  def search_path
    render_component
  end
end
#+END_SRC

Browsing http://localhost:3000/home/search_path rendered
is =Components::Home::Top=.

Specifying the component by name, yields the same result =Components::Home::Top=
#+BEGIN_SRC ruby
class HomeController < ApplicationController
  def search_path
    render_component "SearchPath"
  end
end
#+END_SRC

#+BEGIN_QUOTE
/I want to note this is what I expect to happen, and sometimes it happens, sometimes the components get resolved differently - asking Mitch about it./
#+END_QUOTE

*** Order restarting each time, not quite expected, usually get this order
| Class name changed from SearchPath | Component Rendered           |
|------------------------------------+------------------------------|
| none                               | Home::SearchPath             |
| Home::SearchPath                   | ::SearchPath                 |
| ::SearchPath                       | Components::Home::SearchPath |
| Components::Home::SearchPath       | Components::SearchPath       |
|                                    |                              |

*** Order I expected, that I got a few times - can't presently duplicate
| Class name changed from SearchPath | Component Rendered           |
|------------------------------------+------------------------------|
| none                               | Components::Home::SearchPath |
| Components::Home::SearchPath       | Components::SearchPath       |
| Components::SearchPath             | Home::SearchPath             |
| Home::SearchPath                   | ::SearchPath                 |
|                                    |                              |

So let's change the name of =Components::Home::Top= to =Top1= and refresh,
the component rendered is =Components::Top=, if we change
=Components::Top='s name to ~Top1~ the component rendered is =Home::Top=.
If we rename ~Home::Top~ to ~Top1~ we finally get =::Top=

If we rename all the =Top1= classes back to =Top=, we can force the
search path in the =render_component()= call

#+BEGIN_SRC ruby
class HomeController < ApplicationController
  def search_path
    render_component "SearchPath"
    # render_component "Components::SearchPath"
    # render_component "Components::Home::SearchPath"
    # render_component "Home::SearchPath"
    # render_component "::SearchPath"
  end
end
#+END_SRC

*** Client side only component
If you want to make client only components, to follow conventions with
*react-rails*, make a =components= subdirectory in
=app/views/javascripts= and put them there. Like so:

1.  Make the directory:
#+BEGIN_SRC bash
% mkdir app/assets/javascripts/components
#+END_SRC
1.  [@2] Create =app/assets/javascripts/components/client_only.rb=
    with the following contents:
#+BEGIN_SRC ruby
class ClientOnly
  include React::Component
  required_param :message, type: String

  def render
    h1 { "Client only: #{params[:message]}" }
  end
end
#+END_SRC

Then in the template for the =client_only= action , you can render the
component client side via the =react_component()= method provided by
*react-rails*. This works because *react.rb* wraps calls to
*react.js*, so the components are *react.js* components:

#+BEGIN_SRC html
<h1>Home#client_only</h1>
<p>Find me in app/views/home/client_only.html.erb</p>
<%= react_component 'ClientOnly', message: 'World' %>
#+END_SRC

** That's all for now.
All this code exists in a rails project [[https://github.com/fkchang/getting-started-react-rails][here.]] This should be enough to
get one started.  Follow-on *react.rb* articles to follow.  Enjoy
*react.rb* and Rails!
