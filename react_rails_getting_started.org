#+OPTIONS: num:nil toc:nil

* Getting started with react.rb and Rails
#+ATTR_HTML: :target "_blank"
#+ATTR_HTML: :target "_blank"
Last year [[Http://facebook.github.io/react/][React.js]] was the hottest Javascript framework
of 2015. Bringing this goodness to Ruby on Rails is the [[https://github.com/reactjs/react-rails][react-rails]] gem,
provided by the *reactjs* team.  From the project page, React-rails
can:
- Provide various react builds to your asset bundle
- Transform .jsx in the asset pipeline
- Render components into views and mount them via view helper & react_ujs
- Render components server-side with prerender: true
- Generate components with a Rails generator
- Be extended with custom renderers, transformers and view helpers

#+ATTR_HTML: :target "_blank"
While this provides easy integration with Rails, a Rails developer
cannot leverage the full benefits of React.js, which includes
isomorphic/[[https://medium.com/@mjackson/universal-javascript-4761051b7ae9#.rxrgqe5wb][universal]] domain logic code and views, due to different
languages being used on server and client
sides. [[https://github.com/zetachang/react.rb#changing-the-top-level-component-name-and-search-path][React.rb/reactive-ruby]] (*react.rb* from here on) allows you to
write React components in Ruby, courtesy of [[http://opalrb.org][Opal]].  Server side
rendering of react.rb components is also supported, providing the Rails programmer
universal domain logic and views written in Ruby.

I plan to write in depth about react.rb in subsequent posts. Let's get
react.rb up and running on Rails from scratch.

* Step 1: Generate a rails project that uses Opal

#+ATTR_HTML: :target "_blank"
The easiest way to create a Rails project that uses [[http://opalrb.org][Opal]] is use the
=--javascript=opal= option. Manual instructions are given on the
[[https://github.com/opal/opal-rails][opal-rails]] site.

#+BEGIN_SRC bash
% rails new getting-started-react-rails --javascript=opal
#+END_SRC

* Add react.rb gems to Gemfile

To use react.rb, you need to add 3 gems to your Gemfile:
reactive-ruby[fn:gem_names], react-rails and therubyracer

#+BEGIN_SRC ruby
gem 'reactive-ruby', '0.7.28' # nail down compatible version w/ react-rails
gem 'react-rails', '1.3.2' # react.rb not compatible ith 1.4.* yet so use this one
gem 'opal-rails' # already added w/the --javascript=opal option
gem 'therubyracer', platforms: :ruby # Required for prerendering
#+END_SRC

Run =bundle install= after these have been added to your Gemfile.

* Convert application.js to application.rb

When using opal-rails, it is recommented[fn:opal_rails_recommendation]
to convert the application.js file to application.rb.  Make yours look
like this:

#+BEGIN_SRC ruby
# app/assets/javascripts/application.rb
require 'opal'
require 'opal_ujs'
require 'turbolinks'
require 'react'
require 'react_ujs'
require 'components' # to include isomorphic react components on the client
require_tree '.'
#+END_SRC

* Setup for universal React components

#+ATTR_HTML: :target "_blank"
#+ATTR_HTML: :target "_blank"
A big perk of react.js is universal code (same code on server and
client side), which leads to A unified UI layer. As mentioned before
[[https://github.com/reactjs/react-rails][react-rails]] provides server rendered react components and other perks as detailed in
this [[http://bensmithett.com/server-rendered-react-components-in-rails/][this article]].  It's a pretty big perk, per this quote from the aforementioned article.

#+BEGIN_QUOTE
The Holy Grail. The united UI layer. Serve up real HTML on first page load, then kick off a client side JS app. All without duplicating a single line of UI code.
#+END_QUOTE

Those who have struggled with duplicated views on front and back in
different languages should appreciate that sentiment. To support
universal react.rb components you need to setup a structure for
these *shared* components. The current convention is to make a
=app/views/components= directory containing the components and a
=components.rb= manifest file that will require all the *shared*
components, like so:

#+BEGIN_SRC ruby
# app/views/components.rb
require 'opal'
require 'reactive-ruby'
require_tree './components'
#+END_SRC

You will have noticed that, in the =application.rb=, I
=require=s this =components.rb= file to allow these universal
components to be compiled.

* Make a controller to demonstrate react components

We will be covering several types of components, let's make a
dedicated controller to display these with actions for each case.

#+BEGIN_SRC bash
% rails g controller home isomorphic iso_convention search_path client_only
#+END_SRC

* Create your first React Component

So now that we're setup for isomorphic components, lets make our first
react.rb component.  We'll start with a simple "Hello World" type of
component nature. This component takes a single, required param (prop
in react.js lingo; I use "param" to make it familiar for Rails
programmers) message of type =String=. The component renders this
message in an *h1* element, and renders a button that, when clicked,
calls =alert()= with the same message.

Put the following into this file *app/views/components/hello.rb*:

#+BEGIN_SRC ruby
class Hello
  include React::Component
  required_param :what, type: String

  def message
    "Hello #{what}"
  end

  def render
    div {
      h1 { message }
      button {"Press me"}.on(:click) {alert message}
    }
  end
end
#+END_SRC

You can render the =Hello= component in your controller with
=render_component()=. =render_component()= takes an optional (more on
this later) name of the component and any parameters you wish to pass
the component.  Fill in the =isomorphic= action in the =HomeController= like so

#+BEGIN_SRC ruby
class HomeController < ApplicationController
  def isomorphic
    render_component 'Hello', message: 'World'
  end
end
#+END_SRC

Start the server, then visit [[http://localhost:3000/home/isomorphic][http://localhost:3000/home/isomorphic]] to view the component.
By default it prerenders on the server, but you can force Rails to not
prerender by appending ?no_prerender=1 to the url, like so

#+BEGIN_SRC bash
http://localhost:3000/home/isomorphic?no_prerender=1
#+END_SRC

Let's take a quick look on what gets returned by the server (formatted to be more human-readable)

For [[http://localhost:3000/home/isomorphic][http://localhost:3000/home/isomorphic]]
we see the *h1* and button rendered from the server:
#+BEGIN_SRC html
  <div data-react-class="React.TopLevelRailsComponent"
       data-react-props="{&quot;render_params&quot;:{&quot;message&quot;:&quot;World&quot;},&quot;component_name&quot;:&quot;Hello&quot;,&quot;controller&quot;:&quot;Home&quot;}">
    <div data-reactid=".3hx9dqn6rk"
         data-react-checksum="487927662">
      <h1 data-reactid=".3hx9dqn6rk.0">Hello World</h1>
      <button data-reactid=".3hx9dqn6rk.1">Press me</button>
    </div>
  </div>
#+END_SRC

For [[http://localhost:3000/home/isomorphic?no_prerender=1][http://localhost:3000/home/isomorphic?no_prerender=1]]
there is no prerendering and the rendering is done by the client
#+BEGIN_SRC html
  <div data-react-class="React.TopLevelRailsComponent"
       data-react-props="{&quot;render_params&quot;:{&quot;message&quot;:&quot;World&quot;},&quot;component_name&quot;:&quot;Hello&quot;,&quot;controller&quot;:&quot;Home&quot;}">
  </div>
#+END_SRC

* Rails conventions, isomorphic (i.e. universal) components and the default component

In the Rails tradition of convention over configuration, you can
structure your components to match your controllers to support a
"default" component for each controller action. To make a default component
for the =HomeController#iso_convention= action create the following file:

#+BEGIN_SRC ruby
# app/views/components/home/iso_convention.rb
  module Components
    module Home
      class IsoConvention
        include React::Component

        def render
          h1 { "the message is: #{params[:message]}" }
        end
      end
    end
  end
#+END_SRC

We now call =render_component()= in the action, passing only the
component params in the action.  =render_component()= will instantiate
the *default* component.

#+BEGIN_SRC ruby
class HomeController < ApplicationController
  def iso_convention
    render_component message: 'World'
  end
end
#+END_SRC

Browsing [[http://localhost:3000/home/iso_convention][http://localhost:3000/home/iso_convention]]
will render the =Components::IsoConvention= component

* The component search path

  For consistency with Rails you should stick with the directory and
  filename conventions. There is some flexibility in where you can
  place components. The search path for isomorphic components is
  described here: [[https://github.com/zetachang/react.rb#changing-the-top-level-component-name-and-search-path][here]] which writes:

#+BEGIN_QUOTE
Changing the top level component name and search path

   You can control the top level component name and search path.

   You can specify the component name explicitly in the
   render_component method. render_component "Blatz will search the
   for a component class named Blatz regardless of the controller
   method.

   Searching for components normally works like this: Given a
   controller named "Foo" then the component should be either in the
   Components::Foo module, the Components module (no controller -
   useful if you have just a couple of shared components) or just the
   outer scope (i.e. Module) which is useful for small apps.

   Saying render_component "::Blatz" will only search the outer scope,
   while "::Foo::Blatz" will look only in the module Foo for a class
   named Blatz.
#+END_QUOTE

* Playing around with the search path
Let's play around with several components with the same class name and
see how the search path resolves which component to use.  Create the 2
files below:

=app/views/components/search_path.rb=
#+BEGIN_SRC ruby

  # This class departs from 1 class/file and diretory
  # strctureconvention, using this to test search path

class SearchPath
  include React::Component
  def render
    h1 {"::SearchPath"}
  end
end

module Home
  class SearchPath
    include React::Component
    def render
      h1 {"Home::SearchPath"}
    end
  end
end

module Components
  class SearchPath
    include React::Component
    def render
      h2 { 'Components::SearchPath' }
    end
  end
end

module Components
  module Home
    class SearchPath
      include React::Component
      def render
        h2 { 'Components::Home::SearchPath' }
      end
    end
  end
end
#+END_SRC

To get the "default" component, we can just call =render_component()=:

#+BEGIN_SRC ruby
class HomeController < ApplicationController
  def search_path
    render_component
  end
end
#+END_SRC

/Scott note: I don't understand what the following sentence is saying:/

Hitting [[http://localhost:3000/home/search_path][http://localhost:3000/home/search_path]] the component rendered
=Home::SearchPath=.

Specifying the component by name, yields the same result =Components::Home::Top=
#+BEGIN_SRC ruby
class HomeController < ApplicationController
  def search_path
    render_component "SearchPath"
  end
end
#+END_SRC

We can explore the search path by changing the found component's name
to =SearchPath1=, and then refreshing
http://localhost:3000/home/search_path to see which component is
found.  Doing this for each found component gets the following
results:

| Class name changed from SearchPath | Component Rendered           |
|------------------------------------+------------------------------|
| none                               | Home::SearchPath             |
| Home::SearchPath                   | Components::Home::SearchPath |
| Components::Home::SearchPath       | ::SearchPath                 |
| ::SearchPath                       | Components::SearchPath       |

If we rename all the =SearchPath1= classes back to =SearchPath=, we
can force the search path to find our desired component by specifying
the full namespace in the =render_component()= call

#+BEGIN_SRC ruby
class HomeController < ApplicationController
  def search_path
    render_component "SearchPath"
    # render_component "Components::SearchPath"
    # render_component "Components::Home::SearchPath"
    # render_component "Home::SearchPath"
    # render_component "::SearchPath"
  end
end
#+END_SRC

* Conventions for react-rails, Opal and react.rb

The *react-rails* Javascript component generators create react.js
components in the =app/assets/javascripts/components= directory.  This
makes sense, esp. since Rails out of the box does NOT support
isomorphic code and views; hence this is a logical and "Rails-like" place
for them to go.  Similarly, if you are just using opal-rails and not
not react.rb, then by convention, your opal code will be placed under
=app/assets/javascripts= where the asset pipeline knows how to find
and transpile those to javascript.  React.rb challenges these
conventions with code that runs /(Scott: I don't understand the previous sentence)/.
As react.js is often called the *V* of
*MVC*, then it makes sense for react.rb components to live
under the =app/views/components= directory as they can also be
rendered on the server.  React.rb is young, and conventions may
change, but at the momemnt this is where they live

You can create react.rb components more in line with react-rails and
opal conventions by placing them under the =app/assets/javascripts=
directory. The Opal files will be found by Rails anywhere that the
asset pipeline is configured to select javascript files for both server and
client, but I would recommend a structure similar to how react-rails
sets up the structure for react.js components: in the directory
=app/assets/javascripts/components= to make them easy to find.

Let's put the "client side only" component into
=app/assets/javascripts=. Since Opal will find the file anywhere the
asset pipeline knows to look, this would be more for organizational
purposes rather than a required configuration.

#+BEGIN_SRC ruby
# app/assets/javascripts/components/client_only.rb
class ClientOnly
  include React::Component
  required_param :message, type: String

  def render
    h1 { "Client only: #{params[:message]}" }
  end
end
#+END_SRC

Then in the template for the =client_only= action , you can render the
component client side via the =react_component()= view helper provided by
react-rails. Since react.rb wraps calls to
react.js, the components become react.js components.

#+BEGIN_SRC html
<h1>Home#client_only</h1>
<p>Find me in app/views/home/client_only.html.erb</p>
<%= react_component 'ClientOnly', message: 'World' %>
#+END_SRC


* That's all for now.
So now you have a Rails project with react.rb running. All of this code
exists in a rails project [[https://github.com/fkchang/getting-started-react-rails][here.]] This should be enough to get one
started.  There will be react.rb articles to follow.  Enjoy react.rb and
Rails!

* Footnotes

[fn:gem_names] reactive-ruby will fold back into react.rb with the 0.9.0 versions (currently at 0.7.36).  Plans are discussed in the react.rb [[https://github.com/zetachang/react.rb#road-map][roadmap]]

[fn:opal_rails_recommendation]
A change was made starting with Opal 0.8.*, to support ordered
requires. If one wishes to continue to use application.js instead
application.rb, one needs to manually load each opal file in the
application.js, as below.  Use of application.rb will automatically load the files in question

#+BEGIN_SRC javascript
// application.js
//= require opal
//= require greeter
//= require_self
Opal.load('an_opal_file');
Opal.load('another_opal_file');
// etc.
#+END_SRC
