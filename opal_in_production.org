One thing I believe thats hinders [[http://opalrb.org][Opal's]] adoption is that people are
unsure whether Opal is "ready for production." On May 8, 2015, we
deployed an Opal (and Rails) app to production.  While I've done a
fair amount of work with Opal in the last few years,
it was only on May 8th that I joined the ranks of those having
deployed a production site using Opal.

This project was quite successful across the board. While I largely
attribute the success to our (Agile) process, the technical decision
to use Opal played a significant role in that success.  I hope the
remainder of this article can persuade people on the fence about adopting
Opal to try it.


Some Key Points:

- Lots of tests! This is our first app (out of 8 apps in 6 years) with
  extensive front-end tests.  These are written in RSpec since RSpec
  has been our testing language on the back-end.  We've been able to share some
  of those tests on the front-end.
  - Our other apps don't have much Javascript functionality in the front end.
    As a result, vanilla
    Rails has generally served the client-side requirement of these apps quite well.
    Historically, we have tried repeatedly to supply comprehensive Javascript
    tests, going all the way back with [[http://thinkrelevance.com/blog/2009/05/12/blue-ridge-1-0-javascript-unit-testing-for-rails-scandalous][blueridge]] and subsequent
    newer approaches such as Jasmine, etc.  It seems we always experienced
    mixed success both implementing and maintaining the tests,
    but since these apps didn't have much front-end functionality,
    we could "live with it".
  - All that changed with app which has complex business rules
    that have to run on both the
    server and client.  There is considerably more user
    interaction, and so testing was far more more critical to this
    app's timely success.
  - It's not that you can't write comprehensive unit tests in
    Javascript --- many teams have succeedfed where we failed. However, Opal
    makes client-side testing much easier for Rubyists by using the same
    language, knowledge and test framework on both ends.
    Personally I have a much better TDD/BDD focus in Ruby than
    Javascript.
  - Many frameworks copy or are inspired by [[http://rspec.info][RSpec]].  Having Opal lets
    the Rubyist use the original instead of a Javascript derivative
    For Rubyists that don't like RSpec (like DHH), [[https://github.com/skofo/opal-minitest][minitest]] is also available.
  - For the code that implements the business rules, Ruby provides seamless
    inheritance and mixins.  Although these are on the horizon for Javascript,
    there will be a "break-in" period as the different browsers that need to
    be supported come up to speed.
  - Finally, the [[https://github.com/opal/opal-rspec#async-examples][async examples]] in [[https://github.com/opal/opal-rspec][opal-rspec]] do a great job of showing how
    to easily work around Ruby's more primitive asynchronous support.

- "Isomorphic" - Running the same code on the front end as the back end, is good.
  - It's as big a deal as the Meteor guys say it is, except with
    Opal lets you use the better (bias noted!) Ruby programming language.
    Some benefits are:
    - Reuse code on front/backend.
    - Avoid having to switch your mental context between Ruby and Javascript.
    - Use same tools: favorite editor/IDE, guard, rspec etc.
      - We use [[https://github.com/fkchang/opal-irb][opal-irb]] which (sort of) mimicks using the Rails console,
        including accessing live Ruby objects at run-time.
  - The ability to reuse server-side complex business logic code on
    the front end was a driving factor on our team choosing Opal.
    Despite my being an Opal advocate, the team suggested Opal on
    their own without any prompting on my part. I did spike
    what I thought was the most involved scenario as a proof of
    concept; the team liked the way the code looked and went with it.
    - OH: "That would've been really hard if we did it in Javascript"
      -- the team member who started the local Meteor.js meetup (as
      background for someone who isn't a Javascript newbie)
- Challenges - conventions still need to be worked out.  All the production Opal
  apps I know of are closed source, so there's not a lot of code to
  look at, nor much written about it.
  - Where does the code live?  Rails already provides standard
    locations for front end and backend code but where do you put
    shared code? We took a "meteor-esque" way: provide a dedicated
    directory where isomorphic code lives (expect future blog post that will
    discuss details).
  - Explicit require vs auto load?  With the Rails autoloader, one may
    rarely see a require statement in a Rails app.  Since Opal uses
    sprockets to load assets, one can setup a situation where you
    wouldn't need to require things.  Instead we went with explicit
    requires in our Opal code. (Scott: this paragraph is confusing; why
    would you put explicit requires in your Opal code if sprockets implies
    you shouldn't have to.  Clarity needed.)
- TL;DR: Ruby is Joy.  If you love Ruby on the back end, chances are high you'll
  love it on the front end.
  - The code is cleaner, clearer and more maintainable than if we had done it in Javascript.
  - Shared code on both ends.
  - Inheritance and modules work.

Hopefully, this helps answer some questions for would be Opal
adopters.  We're happy with the improved productivity and coding enjoyment
that Opal has brought us.
